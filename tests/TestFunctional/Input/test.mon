package com.apamax.test;
using com.apamax.functional.Functional;
using com.apamax.functional.Generator;

/** This monitor is responsible for ...  */
monitor TestFunctional {

	event Zeros
	{
		action generate() returns integer {
			return 0;
		}
	}
	action onload() {
		log "Loaded monitor TestFunctional" at INFO;

		sequence<string> s := ["Hello World", "Foo bar"];
		s := <sequence<string>> Functional.map(s, replaceWithCows/* (any a) -> "cow" */);
		Asserts.assertEquals("map sequence string", s, ["cow", "cow"]);

		sequence<integer> s2 := [1, 2, 3];
		s := <sequence<string>> Functional.map(s2, replaceWithCows/* (any a) -> "cow" */);
		Asserts.assertEquals("map sequence integer", s, ["cow", "cow", "cow"]);

		dictionary<string, integer> d2 := {"Hello world":1, "Foo":2};
		dictionary<string, string> d := <dictionary<string, string>> Functional.map(d2, replaceValueWithCows/* (string k, any v) -> "cow" */);
		Asserts.assertEquals("map dictionary", d, {"Hello world":"cow", "Foo":"cow"});

		s.append("notacow");
		s.insert("notacow", 1);
		s := <sequence<string>> Functional.filter(s, checkForCow/* (string s) -> s="cow" */);
		Asserts.assertEquals("filter sequence", s, ["cow", "cow", "cow"]);

		d["baz"] := "quux";
		d["to be or"] := "not to be";
		d := <dictionary<string, string>> Functional.filter(d, checkValueForCow/* (string k, string v) -> v="cow" */);
		Asserts.assertEquals("filter dictionary", d, {"Hello world":"cow", "Foo":"cow"});

		sequence<integer> si := [1,3,5,7,9];
		float sum := <float> Functional.reduce(si, addup/* (float a, integer v) -> acc+v.toFloat() */);
		Asserts.assertEquals("reduce sequence", sum, 25.);

		dictionary<string, integer> dsi := {"a":2, "b":4, "c":5};
		string dstr := <string> Functional.reduce(dsi, stringify/* (string a, string k, integer v) -> acc+k+":"+v.toString()+", " */);
		Asserts.assertEquals("reduce dictionary", dstr, "a:2, b:4, c:5, ");

		Generator g := Functional.count();
		Asserts.assertEquals("generate 0", 0, g.generate());
		Asserts.assertEquals("generate 1", 1, g.generate());
		Asserts.assertEquals("generate 2", 2, g.generate());

		g := <Generator> Functional.filter(g, isEven/*(integer i)->i%2=0 */);
		Asserts.assertEquals("generate filter 4", 4, g.generate());
		Asserts.assertEquals("generate filter 6", 6, g.generate());
		Asserts.assertEquals("generate filter 8", 8, g.generate());

		g := <Generator> Functional.map(g, double/* (integer i)->i*2 */);
		Asserts.assertEquals("generate map 20", 20, g.generate());
		Asserts.assertEquals("generate map 24", 24, g.generate());
		Asserts.assertEquals("generate map 28", 28, g.generate());

		g := Functional.generate(addCow/* (string s) -> s+"cow" */);
		Asserts.assertEquals("generate cow", "cow", g.generate());
		Asserts.assertEquals("generate cowcow", "cowcow", g.generate());
		Asserts.assertEquals("generate cowcowcow", "cowcowcow", g.generate());

		g := <Generator> Functional.map(g, countCows);
		Asserts.assertEquals("generate cow map 4", 4, g.generate());
		Asserts.assertEquals("generate cow map 5", 5, g.generate());
		Asserts.assertEquals("generate cow map 6", 6, g.generate());

		sequence<integer> ncows := <sequence<integer>> Functional.slice(g, 1, 5, 2);
		Asserts.assertEquals("generate slice", ncows,  [8, 10]);
		sequence<string> ss := <sequence<string>> Functional.slice(["a", "b", "c", "d", "e", "f", "g"], 2, -1, 3);
		Asserts.assertEquals("sequence slice", ss, ["c", "f"]);

		Zeros z := new Zeros;
		Asserts.assertEquals("zeros", 0, z.generate());
		Asserts.assertEquals("zeros", 0, z.generate());
		Asserts.assertEquals("zeros", 0, z.generate());
		g := <Generator> Functional.map(z, replaceWithCows);
		Asserts.assertEquals("zero map", "cow", g.generate());
		Asserts.assertEquals("zero map", "cow", g.generate());
		Asserts.assertEquals("zero map", "cow", g.generate());

		Asserts.assertEquals("range zero 1", [0,1,2,3,4], Functional.range(0, 5, 1));
		Asserts.assertEquals("range positive 1", [7,8,9], Functional.range(7, 10, 1));
		Asserts.assertEquals("range positive 3", [6,9,12], Functional.range(6, 13, 3));
		Asserts.assertEquals("range negative 1", [-6, -5, -4], Functional.range(-6, -3, 1));
		Asserts.assertEquals("range cross 2", [-4, -2, 0, 2, 4], Functional.range(-4, 6, 2));

		Asserts.assertEquals("sequenceOf", ["cow", "cow", "cow"], Functional.sequenceOf("cow", 3));

	}
	action replaceWithCows(any a) returns string { return "cow"; }
	action replaceValueWithCows(string k, any v) returns string { return "cow"; }
	action checkForCow(string s) returns boolean { return s = "cow"; }
	action checkValueForCow(string k, string v) returns boolean { return v = "cow"; }
	action addup(float acc, integer value) returns float { return acc+value.toFloat(); }
	action stringify(string acc, string k, integer v) returns string { return acc+k+":"+v.toString()+", "; }
	action isEven(integer i) returns boolean { return i%2=0; }
	action double(integer i) returns integer { return i*2; }
	action addCow(string s) returns string { return s+"cow"; }
	action countCows(string s) returns integer
	{
		integer i := 0;
		integer offs := -1;
		while true {
			offs := s.findFrom("cow", offs+1);
			if offs < 0 { break; }
			i := i + 1;
		}
		return i;
	}
}

