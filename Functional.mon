package com.apamax.functional;

/**
  Represents a generator over a function. This class is used internally by Fuctional, but you can use any event with a generate method.
  Generate methods must take 0 arguments and can return the type of your choice (or any).
 */
event Generator
{
	/** @private */
	static action create(any start, any func) returns Generator
	{
		Generator g := new Generator;
		g.accumulator := start;
		g.func := func.getGenericAction();
		g.args := [g.accumulator];
		return g;
	}

	/**
	  Returns the next item from this generator.
	  @returns The next item.
	*/
	action generate() returns any
	{
		args[0] := accumulator;
		accumulator := func(args);
		return accumulator;
	}

	/** @private */
	any accumulator;
	/** @private */
	action<sequence<any>> returns any func;
	/** @private */
	sequence<any> args;
}

/** @private */
event GenerateIf
{
	action generate(any _) returns any
	{
		while true {
			any candidate := wrapped(wrappedargs);
			args[0] := candidate;
			if <boolean> predicate(args) {
				return candidate;
			}
		}
		return new any; // never happens
	}
	action<sequence<any>> returns any wrapped;
	action<sequence<any>> returns any predicate;
	sequence<any> wrappedargs;
	sequence<any> args;
}
/** @private */
event GenerateWrap
{
	action generate(any _) returns any
	{
		args[0] := wrapped(wrappedargs);
		return func(args);
	}
	action<sequence<any>> returns any wrapped;
	action<sequence<any>> returns any func;
	sequence<any> wrappedargs;
	sequence<any> args;
}

/** @private */
event AccumulateGenerator
{
	static action create(any container, any func) returns AccumulateGenerator
	{
		AccumulateGenerator ag := new AccumulateGenerator;
		ag.container := container;
		ag.func := func.getGenericAction();

		string tn := container.getTypeName();
		if tn.find("sequence<") = 0 {
			ag.index := 0;
		} else if container.hasAction("generate") {
			/*action<sequence<any>> returns any act := container.getAction("generate").getGenericAction();
			any foo := <action<sequence<any>> returns any> act;
			foo := <action<sequence<any>> returns any> ag.index;*/
			ag.index := container.getAction("generate");
		} else {
			throw com.apama.exceptions.Exception("Can only accumulate over sequence or generator types", "typeException");
		}
		ag.args := [new any, new any];
		ag.acc := any.newInstance(func.getActionReturnTypeName());
		return ag;
	}
	action generate(any _) returns any
	{
		any value := new any;
		switch(index) {
			/*case action<sequence<any>> returns any: {
				// it's a generator
				value := index(args);
			}*/
			case integer: {
				// it's a sequence
				if not container.hasEntry(index) { return new any; }
				value := container.getEntry(index);
				self.index := index + 1;

			}
			default: {
				value := index.getGenericAction()(new sequence<any>);
			}
		}
		args[0] := acc;
		args[1] := value;
		acc := func(args);
		log "before: "+args[0].toString()+", value: "+value.toString()+", after: "+acc.toString();
		return acc;
	}
	any container;
	action<sequence<any>> returns any func;
	sequence<any> args;
	any acc;
	any index;
}

/**

Provides functional operations on EPL containers, such as map, reduce, filter and slice.

Also provides generators which can be used as input to the functional operations.

eg: <tt>Functional.slice(Functional.map(Functional.filter(Functional.count(), (integer i)->i%2=0), (integer i)->i*2), 2, 8, 2);</tt>

*/
event Functional
{
	/**
	  Takes either a sequence, a dictionary or a generator and filters the contents using a boolean predicate func.

	  eg: <tt>Functional.filter(numbers, (integer i)->i%2=0)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPE&gt; container</tt> and <tt>action&lt;TYPE&gt; returns boolean func</tt> will return <tt>sequence&lt;TYPE&gt;</tt> containing all the elements for which <tt>func</tt> returned true.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPE&gt; container</tt> and <tt>action&lt;KEYTYPE,VALUETYPE&gt; returns boolean func</tt> will return <tt>dictionary&lt;KEYTYPE,VALUETYPE&gt;</tt> containing all the elements for which <tt>func</tt> returned true.</li>
	  	<li>A generator returning <tt>TYPE</tt> and <tt>action&lt;TYPE&gt; returns boolean func</tt> will return a generator returning <tt>TYPE</tt> which only generates items from the original generator for which <tt>func</tt> returned true.</li>
	  </ul>
	  @param container A sequence, dictionary or generator.
	  @param func A boolean predicate function or lambda.
	  @returns The container filtered using the predicate function.
	*/
	static action filter(any container, any func) returns any
	{
		string tn := container.getTypeName();
		any newcontainer := new any;
		action<sequence<any>> returns any genericFunc := func.getGenericAction();
		if tn.find("sequence<") = 0 {
			newcontainer := any.newInstance(tn);
			action<integer> setsize := <action<integer>> newcontainer.getAction("setSize");
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			setsize(getsize());
			any value := new any;
			integer index := 0;
			sequence<any> args := [value];
			for value in container.getEntries() {
				args[0] := value;
				if <boolean> genericFunc(args) {
					newcontainer.setEntry(index, value);
					index := index + 1;
				}
			}
			setsize(index);
		} else if tn.find("dictionary<") = 0 {
			newcontainer := any.newInstance(tn);
			any key := new any;
			sequence<any> args := [key, key];
			for key in container.getKeys() {
				args[0] := key;
				any value := container.getEntry(key);
				args[1] := value;
				if <boolean> genericFunc(args) {
					newcontainer.setEntry(key, value);
				}
			}
		} else if container.hasAction("generate") {
			newcontainer := Generator.create(new any, GenerateIf(container.getAction("generate").getGenericAction(), genericFunc, new sequence<any>, [new any]).generate);
		} else {
			throw com.apama.exceptions.Exception("Can only filter over container or generator types", "typeException");
		}
		return newcontainer;
	}

	/**
	  Takes either a sequence, a dictionary or a generator and maps the contents using a function.

	  eg: <tt>Functional.map(numbers, (integer i)->i*2)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPEA&gt; container</tt> and <tt>action&lt;TYPEA&gt; returns TYPEB func</tt> will return <tt>sequence&lt;TYPEB&gt;</tt> containing the result of running <tt>func</tt> on all the elements in <tt>container</tt>.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPEA&gt; container</tt> and <tt>action&lt;KEYTYPE,VALUETYPEA&gt; returns VALUETYPEB func</tt> will return <tt>dictionary&lt;KEYTYPE,VALUETYPEB&gt;</tt> containing the keys from <tt>container</tt> with the values being the result of running <tt>func</tt>.</li>
	  	<li>A generator returning <tt>TYPEA</tt> and <tt>action&lt;TYPEA&gt; returns TYPEB func</tt> will return a generator returning <tt>TYPEB</tt> where each item is the corresponding item from the original generator after running <tt>func</tt>.</li>
	  </ul>
	  @param container A sequence, dictionary or generator.
	  @param func A function or lambda from old value type to new value type.
	  @returns The container with all the values run through func.
	*/
	static action map(any container, any func) returns any
	{
		string tn := container.getTypeName();
		any newcontainer := new any;
		action<sequence<any>> returns any genericFunc := func.getGenericAction();
		if tn.find("sequence<") = 0 {
			newcontainer := any.newInstance("sequence<"+func.getActionReturnTypeName()+">");
			action<integer> setsize := <action<integer>> newcontainer.getAction("setSize");
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			setsize(getsize());
			any value := new any;
			integer index := 0;
			sequence<any> args := [value];
			for value in container.getEntries() {
				args[0] := value;
				newcontainer.setEntry(index, genericFunc(args));
				index := index + 1;
			}
		} else if tn.find("dictionary<") = 0 {
			newcontainer := any.newInstance("dictionary<"+func.getActionParameterTypeNames()[0]+","+func.getActionReturnTypeName()+">");
			any key := new any;
			sequence<any> args := [key, key];
			for key in container.getKeys() {
				args[0] := key;
				args[1] := container.getEntry(key);
				newcontainer.setEntry(key, genericFunc(args));
			}
		} else if container.hasAction("generate") {
			newcontainer := Generator.create(new any, GenerateWrap(container.getAction("generate").getGenericAction(), genericFunc, new sequence<any>, [new any]).generate);
		} else {
			throw com.apama.exceptions.Exception("Can only map over container or generator types", "typeException");
		}
		return newcontainer;
	}

	/**
	  Takes either a sequence or a dictionary and accumulates all of the values using an accumulator function, returning the final result.

	  eg: <tt>Functional.reduce(numbers, (integer a, integer i)->a+i)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPEA&gt; container</tt> and <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB func</tt> will return the final <tt>TYPEB</tt> after calling <tt>func</tt> on each value, retaining <tt>TYPEB</tt> each time.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPE&gt; container</tt> and <tt>action&lt;TYPEB,KEYTYPE,VALUETYPE&gt; returns TYPEB func</tt> will return the final <tt>TYPEB</tt> after calling <tt>func</tt> on each key and value, retaining <tt>TYPEB</tt> each time.</li>
	  </ul>
	  @param container A sequence or dictionary.
	  @param func An accumulator function or lambda.
	  @returns The final result of the accumulator function.
	*/
	static action reduce(any container, any func) returns any
	{
		string tn := container.getTypeName();
		any accumulator := any.newInstance(func.getActionReturnTypeName());
		action<sequence<any>> returns any genericFunc := func.getGenericAction();
		if tn.find("sequence<") = 0 {
			any value := new any;
			sequence<any> args := [accumulator, value];
			for value in container.getEntries() {
				args[0] := accumulator;
				args[1] := value;
				accumulator := genericFunc(args);
			}
		} else if tn.find("dictionary<") = 0 {
			any key := new any;
			sequence<any> args := [accumulator, key, key];
			sequence<any> keys := container.getKeys();
			keys.sort();
			for key in keys {
				args[0] := accumulator;
				args[1] := key;
				args[2] := container.getEntry(key);
				accumulator := genericFunc(args);
			}
		} else {
			throw com.apama.exceptions.Exception("Can only reduce over container or generator types", "typeException");
		}
		return accumulator;
	}

	/**
	  Takes either a sequence or a generator and returns a given sub-range as a finite sequence. If it is passed a generator, it will invoke the generator sufficient times immediately to satisfy the slice.

	  eg: <tt>Functional.slice(numbers, 5, 20, 2)</tt>

	  @param container A <tt>sequence&lt;TYPE&gt;</tt> or generator which produces <tt>TYPE</tt>.
	  @param start The first item to return.
	  @param end The last item to return (-1 = all, only permitted for sequences).
	  @param stride The number of items to increment each time (1 = all).
	  @returns A <tt>sequence&lt;TYPE&gt;</tt> containing the selected values from <tt>container</tt>
	*/
	static action slice(any container, integer start, integer end, integer stride) returns any
	{
		if start < 0 { throw com.apama.exceptions.Exception("Cannot start a slice at a negative number", "argumentException"); }
		if stride < 1 { throw com.apama.exceptions.Exception("Slice stride must be at least 1", "argumentException"); }

		string tn := container.getTypeName();
		any slice := new any;
		if tn.find("sequence<") = 0 {
			slice := any.newInstance(tn);
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			integer size := getsize();
			action<sequence<any>> returns any append := slice.getAction("append").getGenericAction();
			sequence<any> args := [new any];
			integer i := start;
			end := integer.min(end, size);
			if end < 0 { end := size; }
			while i < end {
				args[0] := container.getEntry(i);
				any _ := append(args);
				i := i + stride;
			}
		} else if container.hasAction("generate") {
			if end < 0 { throw com.apama.exceptions.Exception("Cannot end a slice of a generator at a negative number", "argumentException"); }
			action<> returns any generate := <action<> returns any> container.getAction("generate");
			any value := generate();
			if slice.empty() {
				slice := any.newInstance("sequence<"+value.getTypeName()+">");
			}
			action<sequence<any>> returns any append := slice.getAction("append").getGenericAction();
			sequence<any> args := [new any];
			integer i := 0;
			while i < start { value := generate(); i := i + 1; }
			while i < end {
				args[0] := value;
				any _ := append(args);
				integer j := 0;
				while j < stride { value := generate(); i := i + 1; j := j + 1; }
			}
		} else {
			throw com.apama.exceptions.Exception("Can only slice sequence or generator", "typeException");
		}
		return slice;
	}
	/**
	  Create a generator from a function, which is passed the previous value and should return the next value.
	  The initial value will be a default-initialized <tt>TYPE</tt> and the result of first generation will be the result of invoking <tt>func</tt> on that default-initialized value. To specify the initial value, use generateFrom.

	  eg: <tt>Functional.generate((integer i)->i+1)</tt>

	  @param func An <tt>action&lt;TYPE&gt; returns TYPE</tt> action or lambda which takes the previous value and returns the next value.
	  @returns A generator for <tt>TYPE</tt>.
	*/
	static action generate(any func) returns Generator
	{
		return Generator.create(any.newInstance(func.getActionReturnTypeName()), func);
	}
	/**
	  Create a generator from a function, which is passed the previous value and should return the next value.

	  eg: <tt>Functional.generate(100, (integer i)->i+1)</tt>

	  @param start The value to pass to func to generate the first generation.
	  @param func An <tt>action&lt;TYPE&gt; returns TYPE</tt> action or lambda which takes the previous value and returns the next value.
	  @returns A generator for <tt>TYPE</tt>.
	*/
	static action generateFrom(any start, any func) returns Generator
	{
		return Generator.create(start, func);
	}

	/** @private */
	static action increment(integer i) returns integer { return i+1; }
	/**
	  Returns a generator producing sequential integers with the first one being 0.
	*/
	static action count() returns Generator
	{
		return generateFrom(-1, increment/* (integer i) -> i+1 */);
	}

	/**
	  Returns a range of integers from <tt>start</tt> (inclusive) to <tt>end</tt> (exclusive), incrementing <tt>stride</tt> each time.
	*/
	static action range(integer start, integer end, integer stride) returns sequence<integer>
	{
		// better would be slice(generateFrom(start-1, (integer i)->i+stride), 0, (end-start)/stride, 1)
		return <sequence<integer>> slice(generateFrom(start-1, increment), 0, end-start, stride);
	}

	/** @private */
	static action identity(any a) returns any { return a; }
	/**
	  Repeats the given element forever.
	  @param item The item to return.
	  @returns A generator which returns item over and over again.
	*/
      	static action repeat(any item) returns Generator
	{
		return generateFrom(item, identity/* (any a)->a */);
	}
	/** TODO - loops iterations of seq forever 
	static action cycle(any seq) returns Generator
	{
		//TODO
	}*/
	/** TODO - values are seq<any> sets of arguments to func 
	static action argmap(any seq, any func) returns Generator
	{
		//TODO
	}*/
	/**
	  Returns a sequence containing the given item the given number of times.
	  @param item The element to put in the sequence.
	  @param n The number of times to repeat the element.
	  @returns A <tt>sequence&lt;ITEMTYPE&gt;</tt> with <tt>n</tt> <tt>item</tt>s in it.
	*/
	static action sequenceOf(any item, integer n) returns any
	{
		return slice(repeat(item), 0, n, 1);
	}

	/**
	  Returns a generator which accumulates over the underlying container, returning the result after accumulating each item.
	  Similar to reduce, but returns a generator for each item in turn, rather than just the final total.
	  @param container The sequence, dictionary or generator to accumulate.
	  @param func An <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB</tt> action or lambda which accumulates each item in turn and returns the new total.
	  @returns A generator which returns each accumulated item in turn.
	  @see reduce
	*/
      	static action accumulate(any container, any func) returns Generator
	{
		return Generator.create(new any, AccumulateGenerator.create(container, func).generate);
	}

	/**
	  Action for adding up a sequence or generator of integer, float or decimal using accumulate or reduce.

	  eg: <tt>integer sum := Functional.reduce(numbers, Functional.sum);</tt>
	*/
	static action sum(any acc, any i) returns any
	{
		switch (i) {
			case integer: {
				if acc.empty() { acc := 0; }
				return i+<integer> acc;
			}
			case float: {
				if acc.empty() { acc := 0.; }
				return i+<float> acc;
			}
			case decimal: {
				if acc.empty() { acc := 0.d; }
				return i+<decimal> acc;
			}
		}
	}
	/** TODO 
	static action mul(any acc, any i) returns any
	{
		//TODO
	}*/
	/** TODO 
	static action conact(string acc, string i) returns string
	{
		//TODO
	}*/
	/** TODO 
	static action even(integer i) returns boolean
	{
		//TODO
	}*/
	/** TODO 
	static action odd(integer i) returns boolean
	{
		//TODO
	}*/
	/** TODO 
	static action whole(any i) returns boolean
	{
		//TODO
	}*/
	/** TODO 
	static action positive(any i) returns boolean
	{
		//TODO
	}*/
	/** TODO 
	static action negative(any i) returns boolean
	{
		//TODO
	}*/
	/** TODO - return a functor which will pass the given arguments, followed by the actual arguments, for partially evaluated functions 
	static action partial(any func, sequence<any> args) returns ...
	{
		//TODO
	}*/
}

