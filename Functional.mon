package com.apamax.functional;

/** @private */
event Util
{
	static action getGenericAction(any func) returns action<sequence<any>> returns any
	{
		switch (func) {
			case action<sequence<any>> returns any: {
				return func;
			}
			default: {
				return func.getGenericAction();
			}
		}
	}

	/** Convert value(s) of arg to a sequence<any> containing the value(s).
		If arg is not a sequence, create the sequence and put the value in it.
		If arg is already a sequence, copy the values from the sequence.
	*/ 
	static action getGenericSequence(any arg) returns sequence<any> {
		// log "gGS: " + arg.toString();
		// log "res: " + arg.getEntries().toString();
		return arg.getEntries();
	}
}

/**
  Represents a generator over a function. This class is used internally by Fuctional, but you can use any event with a generate method.
  Generate methods must take 0 arguments and can return the type of your choice (or any).
 */
event Generator
{
	/** @private */
	static action create(any start, any func) returns Generator
	{
		Generator g := new Generator;
		g.accumulator := start;
		g.func := Util.getGenericAction(func);
		g.args := [g.accumulator];
		return g;
	}

	/**
	  Returns the next item from this generator.
	  @returns The next item.
	*/
	action generate() returns any
	{
		args[0] := accumulator;
		accumulator := func(args);
		return accumulator;
	}

	/** @private */
	any accumulator;
	/** @private */
	action<sequence<any>> returns any func;
	/** @private */
	sequence<any> args;
}

/** @private */
event GenerateIf
{
	action generate(any _) returns any
	{
		while true {
			any candidate := wrapped(wrappedargs);
			args[0] := candidate;
			if <boolean> predicate(args) {
				return candidate;
			}
		}
		return new any; // never happens
	}
	action<sequence<any>> returns any wrapped;
	action<sequence<any>> returns any predicate;
	sequence<any> wrappedargs;
	sequence<any> args;
}
/** @private */
event GenerateWrap
{
	action generate(any _) returns any
	{
		args[0] := wrapped(wrappedargs);
		return func(args);
	}
	action<sequence<any>> returns any wrapped;
	action<sequence<any>> returns any func;
	sequence<any> wrappedargs;
	sequence<any> args;
}

/** @private */
event AccumulateGenerator
{
	static action create(any container, any func) returns AccumulateGenerator
	{
		AccumulateGenerator ag := new AccumulateGenerator;
		ag.container := container;
		ag.func := Util.getGenericAction(func);

		string tn := container.getTypeName();
		if tn.find("sequence<") = 0 {
			ag.index := 0;
		} else if container.hasAction("generate") {
			/*action<sequence<any>> returns any act := container.getAction("generate").getGenericAction();
			any foo := <action<sequence<any>> returns any> act;
			foo := <action<sequence<any>> returns any> ag.index;*/
			ag.index := container.getAction("generate");
		} else {
			throw com.apama.exceptions.Exception("Can only accumulate over sequence or generator types", "typeException");
		}
		ag.args := [new any, new any];
		ag.acc := any.newInstance(func.getActionReturnTypeName());
		return ag;
	}
	action generate(any _) returns any
	{
		any value := new any;
		switch(index) {
			/*case action<sequence<any>> returns any: {
				// it's a generator
				value := index(args);
			}*/
			case integer: {
				// it's a sequence
				if not container.hasEntry(index) { return new any; }
				value := container.getEntry(index);
				self.index := index + 1;

			}
			default: {
				value := index.getGenericAction()(new sequence<any>);
			}
		}
		args[0] := acc;
		args[1] := value;
		acc := func(args);
		return acc;
	}
	any container;
	action<sequence<any>> returns any func;
	sequence<any> args;
	any acc;
	any index;
}

/** @private */
event ArgMapGenerator
{
	static action create(action<sequence<any>> returns any source, any func) returns ArgMapGenerator
	{
		ArgMapGenerator ag := new ArgMapGenerator;
		ag.func := Util.getGenericAction(func);
		ag.source := source;
		ag.args := new sequence<any>;
		return ag;
	}
	action generate(any _) returns any
	{
		any args := source(self.args);
		return func(args.getEntries());
	}
	action<sequence<any>> returns any func;
	action<sequence<any>> returns any source;
	sequence<any> args;
}

/** @private */
event SequenceCycleGenerator
{
	static action create(any seq) returns SequenceCycleGenerator
	{
		SequenceCycleGenerator sg := new SequenceCycleGenerator;
		sg.seq := seq;
		sg.seqsize := (<action<> returns integer> seq.getAction("size"))();
		sg.index := 0;
		return sg;
	}
	action generate(any _) returns any
	{
		any value := seq.getEntry(index);
		index := index + 1;
		if index >= seqsize { index := 0; }
		return value;
	}
	any seq;
	integer index;
	integer seqsize;
}

/** @private */
event NotPred
{
	action<sequence<any>> returns any pred;
	sequence<any> args;
	action execute(any i) returns boolean
	{
		args[0] := i;
		return not <boolean> pred(args);
	}
}

/**

Provides functional operations on EPL containers, such as map, reduce, filter and slice.

Also provides generators which can be used as input to the functional operations.

eg: <tt>Fn.slice(Fn.map(Fn.filter(Fn.count(), (integer i)->i%2=0), (integer i)->i*2), 2, 8, 2);</tt>

*/
event Fn
{
/* TODO: 
 - make key the last param for dictionary functors and optional via introspection
 - reduce with optional inital value
*/
	/**
	  Takes either a sequence, a dictionary or a generator and filters the contents using a boolean predicate func.

	  eg: <tt>Fn.filter(numbers, (integer i)->i%2=0)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPE&gt; container</tt> and <tt>action&lt;TYPE&gt; returns boolean func</tt> will return <tt>sequence&lt;TYPE&gt;</tt> containing all the elements for which <tt>func</tt> returned true.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPE&gt; container</tt> and <tt>action&lt;KEYTYPE,VALUETYPE&gt; returns boolean func</tt> will return <tt>dictionary&lt;KEYTYPE,VALUETYPE&gt;</tt> containing all the elements for which <tt>func</tt> returned true.</li>
	  	<li>A generator returning <tt>TYPE</tt> and <tt>action&lt;TYPE&gt; returns boolean func</tt> will return a generator returning <tt>TYPE</tt> which only generates items from the original generator for which <tt>func</tt> returned true.</li>
	  </ul>
	  @param container A sequence, dictionary or generator.
	  @param func A boolean predicate function or lambda.
	  @returns The container filtered using the predicate function.
	*/
	static action filter(any container, any func) returns any
	{
		string tn := container.getTypeName();
		any newcontainer := new any;
		action<sequence<any>> returns any genericFunc := Util.getGenericAction(func);
		if tn.find("sequence<") = 0 {
			newcontainer := any.newInstance(tn);
			action<integer> setsize := <action<integer>> newcontainer.getAction("setSize");
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			setsize(getsize());
			any value := new any;
			integer index := 0;
			sequence<any> args := [value];
			for value in container.getEntries() {
				args[0] := value;
				if <boolean> genericFunc(args) {
					newcontainer.setEntry(index, value);
					index := index + 1;
				}
			}
			setsize(index);
		} else if tn.find("dictionary<") = 0 {
			newcontainer := any.newInstance(tn);
			any key := new any;
			sequence<any> args := [key, key];
			for key in container.getKeys() {
				args[0] := key;
				any value := container.getEntry(key);
				args[1] := value;
				if <boolean> genericFunc(args) {
					newcontainer.setEntry(key, value);
				}
			}
		} else if container.hasAction("generate") {
			newcontainer := Generator.create(new any, GenerateIf(container.getAction("generate").getGenericAction(), genericFunc, new sequence<any>, [new any]).generate);
		} else {
			throw com.apama.exceptions.Exception("Can only filter over container or generator types", "typeException");
		}
		return newcontainer;
	}

	/**
	  Takes either a sequence, a dictionary or a generator and maps the contents using a function.

	  eg: <tt>Fn.map(numbers, (integer i)->i*2)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPEA&gt; container</tt> and <tt>action&lt;TYPEA&gt; returns TYPEB func</tt> will return <tt>sequence&lt;TYPEB&gt;</tt> containing the result of running <tt>func</tt> on all the elements in <tt>container</tt>.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPEA&gt; container</tt> and <tt>action&lt;KEYTYPE,VALUETYPEA&gt; returns VALUETYPEB func</tt> will return <tt>dictionary&lt;KEYTYPE,VALUETYPEB&gt;</tt> containing the keys from <tt>container</tt> with the values being the result of running <tt>func</tt>.</li>
	  	<li>A generator returning <tt>TYPEA</tt> and <tt>action&lt;TYPEA&gt; returns TYPEB func</tt> will return a generator returning <tt>TYPEB</tt> where each item is the corresponding item from the original generator after running <tt>func</tt>.</li>
	  </ul>
	  @param container A sequence, dictionary or generator.
	  @param func A function or lambda from old value type to new value type.
	  @returns The container with all the values run through func.
	*/
	static action map(any container, any func) returns any
	{
		string tn := container.getTypeName();
		any newcontainer := new any;
		action<sequence<any>> returns any genericFunc := Util.getGenericAction(func);
		if tn.find("sequence<") = 0 {
			newcontainer := any.newInstance("sequence<"+func.getActionReturnTypeName()+">");
			action<integer> setsize := <action<integer>> newcontainer.getAction("setSize");
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			setsize(getsize());
			any value := new any;
			integer index := 0;
			sequence<any> args := [value];
			for value in container.getEntries() {
				args[0] := value;
				newcontainer.setEntry(index, genericFunc(args));
				index := index + 1;
			}
		} else if tn.find("dictionary<") = 0 {
			newcontainer := any.newInstance("dictionary<"+func.getActionParameterTypeNames()[0]+","+func.getActionReturnTypeName()+">");
			any key := new any;
			sequence<any> args := [key, key];
			for key in container.getKeys() {
				args[0] := key;
				args[1] := container.getEntry(key);
				newcontainer.setEntry(key, genericFunc(args));
			}
		} else if container.hasAction("generate") {
			newcontainer := Generator.create(new any, GenerateWrap(container.getAction("generate").getGenericAction(), genericFunc, new sequence<any>, [new any]).generate);
		} else {
			throw com.apama.exceptions.Exception("Can only map over container or generator types", "typeException");
		}
		return newcontainer;
	}

	/**
	  Takes either a sequence or a dictionary and accumulates all of the values using an accumulator function, returning the final result.

	  eg: <tt>Fn.reduce(numbers, (integer a, integer i)->a+i)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPEA&gt; container</tt> and <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB func</tt> will return the final <tt>TYPEB</tt> after calling <tt>func</tt> on each value, retaining <tt>TYPEB</tt> each time.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPE&gt; container</tt> and <tt>action&lt;TYPEB,KEYTYPE,VALUETYPE&gt; returns TYPEB func</tt> will return the final <tt>TYPEB</tt> after calling <tt>func</tt> on each key and value, retaining <tt>TYPEB</tt> each time.</li>
	  </ul>
	  @param container A sequence or dictionary.
	  @param func An accumulator function or lambda.
	  @returns The final result of the accumulator function.
	*/
	static action reduce(any container, any func) returns any
	{
		string tn := container.getTypeName();
		any accumulator := any.newInstance(func.getActionReturnTypeName());
		action<sequence<any>> returns any genericFunc := Util.getGenericAction(func);
		if tn.find("sequence<") = 0 {
			any value := new any;
			sequence<any> args := [accumulator, value];
			for value in container.getEntries() {
				args[0] := accumulator;
				args[1] := value;
				accumulator := genericFunc(args);
			}
		} else if tn.find("dictionary<") = 0 {
			any key := new any;
			sequence<any> args := [accumulator, key, key];
			sequence<any> keys := container.getKeys();
			keys.sort();
			for key in keys {
				args[0] := accumulator;
				args[1] := key;
				args[2] := container.getEntry(key);
				accumulator := genericFunc(args);
			}
		} else {
			throw com.apama.exceptions.Exception("Can only reduce over container or generator types", "typeException");
		}
		return accumulator;
	}

	/**
	  Takes either a sequence or a generator and returns a given sub-range as a finite sequence. If it is passed a generator, it will invoke the generator sufficient times immediately to satisfy the slice.

	  eg: <tt>Fn.slice(numbers, 5, 20, 2)</tt>

	  @param container A <tt>sequence&lt;TYPE&gt;</tt> or generator which produces <tt>TYPE</tt>.
	  @param start The first item to return.
	  @param end The last item to return (-1 = all, only permitted for sequences).
	  @param stride The number of items to increment each time (1 = all).
	  @returns A <tt>sequence&lt;TYPE&gt;</tt> containing the selected values from <tt>container</tt>
	*/
	static action slice(any container, integer start, integer end, integer stride) returns any
	{
		if start < 0 { throw com.apama.exceptions.Exception("Cannot start a slice at a negative number", "argumentException"); }
		if stride < 1 { throw com.apama.exceptions.Exception("Slice stride must be at least 1", "argumentException"); }

		string tn := container.getTypeName();
		any slice := new any;
		if tn.find("sequence<") = 0 {
			slice := any.newInstance(tn);
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			integer size := getsize();
			action<sequence<any>> returns any append := slice.getAction("append").getGenericAction();
			sequence<any> args := [new any];
			integer i := start;
			end := integer.min(end, size);
			if end < 0 { end := size; }
			while i < end {
				args[0] := container.getEntry(i);
				any _ := append(args);
				i := i + stride;
			}
		} else if container.hasAction("generate") {
			if end < 0 { throw com.apama.exceptions.Exception("Cannot end a slice of a generator at a negative number", "argumentException"); }
			action<> returns any generate := <action<> returns any> container.getAction("generate");
			any value := generate();
			if slice.empty() {
				slice := any.newInstance("sequence<"+value.getTypeName()+">");
			}
			action<sequence<any>> returns any append := slice.getAction("append").getGenericAction();
			sequence<any> args := [new any];
			integer i := 0;
			while i < start { value := generate(); i := i + 1; }
			while i < end {
				args[0] := value;
				any _ := append(args);
				integer j := 0;
				while j < stride { value := generate(); i := i + 1; j := j + 1; }
			}
		} else {
			throw com.apama.exceptions.Exception("Can only slice sequence or generator", "typeException");
		}
		return slice;
	}
	/**
	  Create a generator from a function, which is passed the previous value and should return the next value.
	  The initial value will be a default-initialized <tt>TYPE</tt> and the result of first generation will be the result of invoking <tt>func</tt> on that default-initialized value. To specify the initial value, use generateFrom.

	  eg: <tt>Fn.generate((integer i)->i+1)</tt>

	  @param func An <tt>action&lt;TYPE&gt; returns TYPE</tt> action or lambda which takes the previous value and returns the next value.
	  @returns A generator for <tt>TYPE</tt>.
	*/
	static action generate(any func) returns Generator
	{
		return Generator.create(any.newInstance(func.getActionReturnTypeName()), func);
	}
	/**
	  Create a generator from a function, which is passed the previous value and should return the next value.

	  eg: <tt>Fn.generate(100, (integer i)->i+1)</tt>

	  @param start The value to pass to func to generate the first generation.
	  @param func An <tt>action&lt;TYPE&gt; returns TYPE</tt> action or lambda which takes the previous value and returns the next value.
	  @returns A generator for <tt>TYPE</tt>.
	*/
	static action generateFrom(any start, any func) returns Generator
	{
		return Generator.create(start, func);
	}

	/** @private */
	static action increment(integer i) returns integer { return i+1; }
	/**
	  Returns a generator producing sequential integers with the first one being 0.
	*/
	static action count() returns Generator
	{
		return generateFrom(-1, increment/* (integer i) -> i+1 */);
	}

	/**
	  Returns a range of integers from <tt>start</tt> (inclusive) to <tt>end</tt> (exclusive), incrementing <tt>stride</tt> each time.
	*/
	static action range(integer start, integer end, integer stride) returns sequence<integer>
	{
		// better would be slice(generateFrom(start-1, (integer i)->i+stride), 0, (end-start)/stride, 1)
		return <sequence<integer>> slice(generateFrom(start-1, increment), 0, end-start, stride);
	}

	/** @private */
	static action identity(any a) returns any { return a; }
	/**
	  Repeats the given element forever.
	  @param item The item to return.
	  @returns A generator which returns item over and over again.
	*/
	static action repeat(any item) returns Generator
	{
		return generateFrom(item, identity/* (any a)->a */);
	}
	/** Iterates through a sequence of items and continues looping forever.
	  @param seq The sequence of values to iterate over
	  @returns A generator which iterates over <tt>seq</tt>
	*/
	static action cycle(any seq) returns Generator
	{
		return generate(SequenceCycleGenerator.create(seq).generate);
	}
	/** Iterates through a sequence, or a generator and uses the result as a list of arguments with which to invoke a function.
		These inner sequences will be treated as a list of arguments to the given function, or a single argument to that function.
		Each generated item will be the result of calling func with the next set of arguments.
		@param container A sequence or a generator.
		@param func A function which takes each item in container and returns a result.
	*/
	static action argmap(any container, any func) returns Generator
	{
		action<sequence<any>> returns any source;
		if container.hasAction("generate") {
			source := container.getAction("generate").getGenericAction();
		} else if container.getTypeName().find("sequence<") = 0 {
			source := (<any>cycle(container).generate).getGenericAction();
		} else {
			throw com.apama.exceptions.Exception("Can only argmap over a sequence or generator", "typeException");
		}
		return generate(ArgMapGenerator.create(source, func).generate);
	}
	/**
	  Returns a sequence containing the given item the given number of times.
	  @param item The element to put in the sequence.
	  @param n The number of times to repeat the element.
	  @returns A <tt>sequence&lt;ITEMTYPE&gt;</tt> with <tt>n</tt> <tt>item</tt>s in it.
	*/
	static action sequenceOf(any item, integer n) returns any
	{
		return slice(repeat(item), 0, n, 1);
	}

	/**
	  Returns a generator which accumulates over the underlying container, returning the result after accumulating each item.
	  Similar to reduce, but returns a generator for each item in turn, rather than just the final total.
	  @param container The sequence, dictionary or generator to accumulate.
	  @param func An <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB</tt> action or lambda which accumulates each item in turn and returns the new total.
	  @returns A generator which returns each accumulated item in turn.
	  @see reduce
	*/
	static action accumulate(any container, any func) returns Generator
	{
		return Generator.create(new any, AccumulateGenerator.create(container, func).generate);
	}

	/**
	  Action for adding up a sequence or generator of integer, float or decimal using accumulate or reduce.

	  eg: <tt>integer sum := Fn.reduce(numbers, Fn.sum);</tt>
	*/
	static action sum(any acc, any i) returns any
	{
		switch (i) {
			case integer: {
				if acc.empty() { acc := 0; }
				return i+<integer> acc;
			}
			case float: {
				if acc.empty() { acc := 0.; }
				return i+<float> acc;
			}
			case decimal: {
				if acc.empty() { acc := 0.d; }
				return i+<decimal> acc;
			}
		}
	}
	/**
	  Action for multiplying together the values in a sequence or generator of integer, float or decimal using accumulate or reduce.

	  eg: <tt>integer product := Fn.reduce(numbers, Fn.mul);</tt>
	*/
	static action mul(any acc, any i) returns any
	{
		switch (i) {
			case integer: {
				if acc.empty() { acc := 1; }
				return i*<integer> acc;
			}
			case float: {
				if acc.empty() { acc := 1.; }
				return i*<float> acc;
			}
			case decimal: {
				if acc.empty() { acc := 1.d; }
				return i*<decimal> acc;
			}
		}
	}
	/**
		Action which concatenates strings using accumulate or reduce.
	*/
	static action concat(string acc, string i) returns string
	{
		return acc+i;
	}
	/**
		A predicate which returns true if the argument is even.
	*/
	static action even(integer i) returns boolean
	{
		return i%2=0;
	}
	/**
		A predicate which returns true if the argument is odd.
	*/
	static action odd(integer i) returns boolean
	{
		return i%2=1;
	}
	/** A predicate which returns true if the argument is a whole number. */
	static action whole(any i) returns boolean
	{
		switch (i) {
			case integer: { return true; }
			case float: { return i.fractionalPart() = 0.; }
			case decimal: { return i.fractionalPart() = 0.d; }
		}
	}
	/** A predicate which returns true if the argument is positive (not including 0). */
	static action positive(any i) returns boolean
	{
		switch (i) {
			case integer: { return i > 0; }
			case float: { return i > 0.; }
			case decimal: { return i > 0.d; }
		}
	}
	/** A predicate which returns true if the argument is negative. */
	static action negative(any i) returns boolean
	{
		switch (i) {
			case integer: { return i < 0; }
			case float: { return i < 0.; }
			case decimal: { return i < 0.d; }
		}
	}
	/** A predicate which inverts the value of another predicate. */
	static action _not(any pred) returns action<any> returns boolean
	{
		return NotPred(pred.getGenericAction(), [new any]).execute;
	}
	/** TODO - return a functor which will pass the given arguments, followed by the actual arguments, for partially evaluated functions 
	static action partial(any func, sequence<any> args) returns ...
	{
		//TODO
	}*/
	/** TODO - run func on pair-wise elements of two iterables 
	static action zipfn(any containerA, any containerB, any func) returns Generator {} */
	/** TODO - take any number of arguments and return them in a sequence
	static action combine(sequence<any> args) returns any {} */
	/** TODO - zipfn with combine as the fn
	static action zip(any containerA, any containerB) returns Generator {} */
	/** TODO - consume n records from generator, returning it
	static action consume(any generator, integer n) returns any {} */
	/** TODO - counts the number of times a predicate is true
	static action quantify(any container, any pred) returns integer {} */
	/** TODO - concatenates two sequences
	static action concatseq(any seqA, any seqB) returns any {} */
	/** TODO - pads sequence with n instances of value
	static action padseq(any seq, any item, integer n) returns any {} */
}

